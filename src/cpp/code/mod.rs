use super::helpers::*;
use super::*;
mod model_getter_setter;
use model_getter_setter::write_model_getter_setter;

/// Entry point for producing the
/// generated C++ code
pub fn write_cpp(conf: &Config) -> Result<()> {
    let mut write_buf = Vec::new();

    let mut h_file = conf.out_dir.join(&conf.cpp_file);
    h_file.set_extension("h");
    let file_name = h_file.file_name().unwrap().to_string_lossy();

    // print header
    writeln!(
        write_buf,
        "/* generated by riqtshaw */\n#include \"{}\"",
        file_name
    )?;

    // start name space
    writeln!(write_buf, "namespace {{")?;

    for option in conf.optional_types() {
        if option != "QString" && option != "QByteArray" {
            writeln!(
                write_buf,
                "
    struct option_{} {{
    public:
        {0} value;
        bool some;
        operator QVariant() const {{
            if (some) {{
                return QVariant::fromValue(value);
            }}
            return QVariant();
        }}
    }};
    static_assert(std::is_pod<option_{0}>::value, \"option_{0} must be a POD type.\");",
                option
            )?;
        }
    }

    writeln!(write_buf, include_str!("../cpp/complex_types.cpp_string"))?;

    for (name, object) in conf.objects.iter() {
        for prop_name in object.non_object_property_names() {
            writeln!(
                write_buf,
                "inline void {fn_name}({class_name}* o)",
                fn_name = changed_f(object, prop_name),
                class_name = name
            )?;
            writeln!(write_buf, "{{\nQ_EMIT o->{}Changed();\n}}", prop_name)?;
        }
    }

    // end namespace
    writeln!(write_buf, "}}")?;

    for o in conf.objects.values() {
        if o.object_type != ObjectType::Object {
            write_cpp_model(&mut write_buf, o)?;
        }

        writeln!(write_buf, "extern \"C\" {{")?;

        write_object_c_decl(&mut write_buf, o, conf)?;

        writeln!(write_buf, "}};\n")?;
    }

    for o in conf.objects.values() {
        write_cpp_object(&mut write_buf, o, conf)?;
    }

    let file = conf.out_dir.join(&conf.cpp_file);

    write_if_different(file, &write_buf)
}

fn write_cpp_object_properties(w: &mut Vec<u8>, o: &Object, lcname: &str) -> Result<()> {
    for (name, p) in &o.properties {
        let base = format!("{}_{}", lcname, snake_case(name));

        if p.is_object() {
            writeln!(
                w,
                "const {}* {}::{}() const
{{
    return m_{2};
}}
{0}* {1}::{2}()
{{
    return m_{2};
}}",
                p.type_name(),
                o.name,
                name
            )?;
        } else if p.is_complex() {
            writeln!(
                w,
                "{} {}::{}() const
{{
    {0} v;
    {3}_get(m_d, &v, set_{4});
    return v;
}}",
                p.type_name(),
                o.name,
                name,
                base,
                p.type_name().to_lowercase()
            )?;
        } else if p.optional {
            writeln!(
                w,
                "QVariant {}::{}() const
{{
    QVariant v;
    auto r = {2}_get(m_d);
    if (r.some) {{
        v.setValue(r.value);
    }}
    return r;
}}",
                o.name, name, base
            )?;
        } else {
            writeln!(
                w,
                "{} {}::{}() const
{{
    return {}_get(m_d);
}}",
                p.type_name(),
                o.name,
                name,
                base
            )?;
        }

        if p.write {
            let t = if p.optional && !p.is_complex() {
                "const QVariant&"
            } else {
                p.property_type.cpp_set_type()
            };

            writeln!(w, "void {}::set{}({} v) {{", o.name, upper_initial(name), t)?;

            if p.optional {
                if p.is_complex() {
                    writeln!(w, "    if (v.isNull()) {{")?;
                } else {
                    writeln!(
                        w,
                        "    if (v.isNull() || !v.canConvert<{}>()) {{",
                        p.type_name()
                    )?;
                }

                writeln!(w, "        {}_set_none(m_d);", base)?;

                writeln!(w, "    }} else {{")?;

                if p.type_name() == "QString" {
                    writeln!(
                        w,
                        "    {}_set(m_d, reinterpret_cast<const ushort*>(v.data()), v.size());",
                        base
                    )?;
                } else if p.type_name() == "QByteArray" {
                    writeln!(w, "    {}_set(m_d, v.data(), v.size());", base)?;
                } else if p.optional {
                    writeln!(
                        w,
                        "        {}_set(m_d, v.value<{}>());",
                        base,
                        p.type_name()
                    )?;
                } else {
                    writeln!(w, "        {}_set(m_d, v);", base)?;
                }
                writeln!(w, "    }}")?;
            } else if p.type_name() == "QString" {
                writeln!(
                    w,
                    "    {}_set(m_d, reinterpret_cast<const ushort*>(v.data()), v.size());",
                    base
                )?;
            } else if p.type_name() == "QByteArray" {
                writeln!(w, "    {}_set(m_d, v.data(), v.size());", base)?;
            } else {
                writeln!(w, "    {}_set(m_d, v);", base)?;
            }

            writeln!(w, "}}")?;
        }
    }
    Ok(())
}

fn write_cpp_object(w: &mut Vec<u8>, o: &Object, conf: &Config) -> Result<()> {
    let lcname = snake_case(&o.name);

    writeln!(
        w,
        "{}::{0}(bool /*owned*/, QObject *parent):
    {}(parent),",
        o.name,
        base_type(o)
    )?;

    initialize_members_zero(w, o)?;

    writeln!(
        w,
        "    m_d(nullptr),
    m_ownsPrivate(false)
{{"
    )?;

    if o.object_type != ObjectType::Object {
        writeln!(w, "initHeaderData();")?;
    }

    writeln!(
        w,
        "}}
{}::{0}(QObject *parent):
    {}(parent),",
        o.name,
        base_type(o)
    )?;

    initialize_members_zero(w, o)?;

    write!(w, "    m_d({}_new(this", lcname)?;

    constructor_args(w, "", o, conf)?;

    writeln!(
        w,
        ")),
    m_ownsPrivate(true)
{{"
    )?;

    initialize_members(w, "", o, conf)?;

    connect(w, "this", o, conf)?;

    if o.object_type != ObjectType::Object {
        writeln!(w, "    initHeaderData();")?;
    }

    writeln!(
        w,
        "}}

{}::~{0}() {{
    if (m_ownsPrivate) {{
        {1}_free(m_d);
    }}
}}",
        o.name, lcname
    )?;

    if o.object_type != ObjectType::Object {
        writeln!(w, "void {}::initHeaderData() {{", o.name)?;

        for col in 0..o.column_count() {
            for (name, ip) in &o.item_properties {
                let empty = Vec::new();

                let roles = ip.roles.get(col).unwrap_or(&empty);

                if roles.contains(&"display".to_string()) {
                    writeln!(
                        w,
                        "    m_headerData.insert(qMakePair({}, Qt::DisplayRole), QVariant(\"{}\"));",
                        col,
                        name
                    )?;
                }
            }
        }

        writeln!(w, "}}")?;
    }

    write_cpp_object_properties(w, o, &lcname)?;

    for (name, f) in &o.functions {
        let base = format!("{}_{}", lcname, snake_case(name));

        write!(w, "{} {}::{}(", f.type_name(), o.name, name)?;

        for (i, a) in f.arguments.iter().enumerate() {
            write!(
                w,
                "{} {}{}",
                a.argument_type.cpp_set_type(),
                a.name,
                if i + 1 < f.arguments.len() { ", " } else { "" }
            )?;
        }

        writeln!(w, "){}\n{{", if f.mutable { "" } else { " const" })?;

        let mut arg_list = String::new();

        for a in &f.arguments {
            if a.type_name() == "QString" {
                arg_list.push_str(&format!(", {}.utf16(), {0}.size()", a.name));
            } else if a.type_name() == "QByteArray" {
                arg_list.push_str(&format!(", {}.data(), {0}.size()", a.name));
            } else {
                arg_list.push_str(&format!(", {}", a.name));
            }
        }

        if f.return_type.name() == "QString" {
            writeln!(
                w,
                "    {} s;
    {}(m_d{}, &s, set_qstring);
    return s;",
                f.type_name(),
                base,
                arg_list
            )?;
        } else if f.return_type.name() == "QByteArray" {
            writeln!(
                w,
                "    {} s;
    {}(m_d{}, &s, set_qbytearray);
    return s;",
                f.type_name(),
                base,
                arg_list
            )?;
        } else {
            writeln!(w, "    return {}(m_d{});", base, arg_list)?;
        }

        writeln!(w, "}}")?;
    }

    Ok(())
}

fn write_cpp_model(w: &mut Vec<u8>, o: &Object) -> Result<()> {
    let lcname = snake_case(&o.name);

    let index = if o.object_type == ObjectType::Tree {
        "index.internalId()"
    } else {
        "index.row()"
    };
    writeln!(w, "extern \"C\" {{")?;

    define_ffi_getters(o, w)?;

    writeln!(
        w,
        "void {}_sort({}::Private*, unsigned char column, Qt::SortOrder order = Qt::AscendingOrder);",
        lcname,
        o.name
    )?;

    if o.object_type == ObjectType::List {
        writeln!(
            w,
            include_str!("../cpp/list_member_fn_defs.cpp_string"),
            name = o.name,
            lowercase_name = lcname,
            column_count = o.column_count()
        )?;
    } else {
        writeln!(
            w,
            include_str!("../cpp/tree_member_fn_defs.cpp_string"),
            o.name,
            lcname,
            o.column_count()
        )?;
    }

    writeln!(
        w,
        "
void {0}::sort(int column, Qt::SortOrder order)
{{
    {1}_sort(m_d, column, order);
}}",
        o.name, lcname
    )?;

    write_abstract_item_flags_function(o, w)?;

    for ip in &o.item_properties {
        write_model_getter_setter(w, index, ip.0, ip.1, o)?;
    }

    writeln!(
        w,
        "QVariant {}::data(const QModelIndex &index, int role) const
{{
    Q_ASSERT(rowCount(index.parent()) > index.row());
    switch (index.column()) {{",
        o.name
    )?;

    for col in 0..o.column_count() {
        writeln!(w, "    case {}:", col)?;

        writeln!(w, "        switch (role) {{")?;

        for (i, (name, ip)) in o.item_properties.iter().enumerate() {
            let empty = Vec::new();
            let roles = ip.roles.get(col).unwrap_or(&empty);
            if col > 0 && roles.is_empty() {
                continue;
            }

            for role in roles {
                writeln!(w, "        case Qt::{}:", role_name(role))?;
            }

            writeln!(w, "        case Qt::UserRole + {}:", i)?;

            let ii = if o.object_type == ObjectType::List {
                ".row()"
            } else {
                ""
            };

            if ip.optional && !ip.is_complex() {
                writeln!(w, "return {}(index{});", name, ii)?;
            } else if ip.optional {
                writeln!(
                    w,
                    "return cleanNullQVariant(QVariant::fromValue({}(index{})));",
                    name, ii
                )?;
            } else {
                writeln!(w, "return QVariant::fromValue({}(index{}));", name, ii)?;
            }
        }

        writeln!(w, "}} break;")?;
    }

    writeln!(
        w,
        "    }}
    return QVariant();
}}"
    )?;

    write_abstract_item_role_function(o, w)?;

    writeln!(
    w,"
QVariant {0}::headerData(int section, Qt::Orientation orientation, int role) const
{{
    if (orientation != Qt::Horizontal) {{
        return QVariant();
    }}
    return m_headerData.value(qMakePair(section, static_cast<Qt::ItemDataRole>(role)), role == Qt::DisplayRole ?QString::number(section + 1) :QVariant());
}}

bool {0}::setHeaderData(int section, Qt::Orientation orientation, const QVariant &value, int role)
{{
    if (orientation != Qt::Horizontal) {{
        return false;
    }}
    m_headerData.insert(qMakePair(section, static_cast<Qt::ItemDataRole>(role)), value);
    return true;
}}
",
        o.name
    )?;

    if model_is_writable(o) {
        writeln!(
            w,
            "bool {}::setData(const QModelIndex &index, const QVariant &value, int role)\n{{",
            o.name
        )?;

        for col in 0..o.column_count() {
            if !is_column_write(o, col) {
                continue;
            }

            writeln!(w, "    if (index.column() == {}) {{", col)?;

            for (i, (name, ip)) in o.item_properties.iter().enumerate() {
                if !ip.write {
                    continue;
                }

                let empty = Vec::new();

                let roles = ip.roles.get(col).unwrap_or(&empty);

                if col > 0 && roles.is_empty() {
                    continue;
                }

                write!(w, "        if (")?;

                for role in roles {
                    write!(w, "role == Qt::{} || ", role_name(role))?;
                }

                writeln!(w, "role == Qt::UserRole + {}) {{", i)?;

                let ii = if o.object_type == ObjectType::List {
                    ".row()"
                } else {
                    ""
                };

                if ip.optional && !ip.is_complex() {
                    writeln!(
                        w,
                        "            return set{}(index{}, value);",
                        upper_initial(name),
                        ii
                    )?;
                } else {
                    let pre = if ip.optional {
                        "!value.isValid() || value.isNull() ||"
                    } else {
                        ""
                    };

                    writeln!(
                        w,
                        "            if ({}value.canConvert(qMetaTypeId<{}>())) {{",
                        pre,
                        ip.type_name()
                    )?;

                    writeln!(
                        w,
                        "                return set{}(index{}, value.value<{}>());",
                        upper_initial(name),
                        ii,
                        ip.type_name()
                    )?;

                    writeln!(w, "}}")?;
                }

                writeln!(w, "}}")?;
            }

            writeln!(w, "}}")?;
        }

        writeln!(w, "return false;\n}}\n")?;
    }

    Ok(())
}

fn constructor_args(w: &mut Vec<u8>, prefix: &str, o: &Object, conf: &Config) -> Result<()> {
    let lcname = snake_case(&o.name);

    for (name, prop) in &o.properties {
        if let Type::Object(object) = &prop.property_type {
            write!(w, ", {}m_{}", prefix, name)?;
            constructor_args(w, &format!("m_{}->", name), object, conf)?;
        } else {
            write!(w, ",\n        {}", changed_f(o, name))?;
        }
    }
    if o.object_type == ObjectType::List {
        writeln!(
            w,
            include_str!("../cpp/list_constructor_lambdas.cpp_string"),
            name = o.name,
            col_count = o.column_count() - 1
        )?;
    }

    if o.object_type == ObjectType::Tree {
        writeln!(
            w,
            include_str!("../cpp/tree_constructor_lambdas.cpp_string"),
            name = o.name,
            snake_case_class_name = lcname,
            col_count = o.column_count() - 1
        )?;
    }

    // add_factory_lambdas(w, o)?;

    Ok(())
}

use super::*;

/// Entry point for producing the
/// generated C++ header code
pub fn write_header(conf: &Config) -> Result<()> {
    let mut h_file = conf.out_dir.join(&conf.cpp_file);

    h_file.set_extension("h");

    let mut header_buf = Vec::new();

    let guard = h_file
        .file_name()
        .unwrap()
        .to_string_lossy()
        .replace(".", "_")
        .to_uppercase();

    writeln!(
        header_buf,
        "/* generated by riqtshaw */
#ifndef {guard}
#define {guard}

#include <QtCore/QObject>
#include <QtCore/QAbstractItemModel>
",
        guard = guard
    )?;

    for name in conf.objects.keys() {
        writeln!(header_buf, "class {name};", name = name)?;
        writeln!(header_buf, "typedef {name}* {name}Ref;", name = name)?;
        writeln!(header_buf, "Q_DECLARE_METATYPE({name}Ref); \n", name = name)?;
    }

    for object in conf.objects.values() {
        write_header_object(&mut header_buf, object, conf)?;
    }

    writeln!(header_buf, "#endif // {guard}", guard = guard)?;

    write_if_different(h_file, &header_buf)?;

    Ok(())
}

fn write_header_item_model(h: &mut Vec<u8>, o: &Object) -> Result<()> {
    writeln!(h, include_str!("cpp/header_item_model.hpp"))?;

    if model_is_writable(o) {
        writeln!(
            h,
            "    bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole) override;"
        )?;
    }

    for (name, ip) in &o.item_properties {
        let r = property_type(ip);

        let rw = if r == "QVariant" || ip.item_property_type.is_complex() {
            format!("const {}&", r)
        } else {
            r.clone()
        };

        if o.object_type == ObjectType::List {
            writeln!(h, "    Q_INVOKABLE {} {}(int row) const;", r, name)?;
            if ip.write {
                writeln!(
                    h,
                    "    Q_INVOKABLE bool set{}(int row, {} value);",
                    upper_initial(name),
                    rw
                )?;
            }
        } else {
            writeln!(
                h,
                "    Q_INVOKABLE {} {}(const QModelIndex& index) const;",
                r, name
            )?;
            if ip.write {
                writeln!(
                    h,
                    "    Q_INVOKABLE bool set{}(const QModelIndex& index, {} value);",
                    upper_initial(name),
                    rw
                )?;
            }
        }
    }

    writeln!(
        h,
        "
Q_SIGNALS:
    // new data is ready to be made available to the model with fetchMore()
    void newDataReady(const QModelIndex &parent) const;
private:
    QHash<QPair<int,Qt::ItemDataRole>, QVariant> m_headerData;
    void initHeaderData();
    void updatePersistentIndexes();"
    )?;

    Ok(())
}

fn write_header_object(h: &mut Vec<u8>, obj: &Object, conf: &Config) -> Result<()> {
    writeln!(
        h,
        "class {} : public {} {{ Q_OBJECT",
        obj.name,
        base_type(obj)
    )?;

    for object in conf
        .objects
        .values()
        .filter(|o| o.contains_object() && o.name != obj.name)
    {
        writeln!(h, "    friend class {};", object.name)?;
    }

    writeln!(
        h,
        "public:
    class Private;
private:"
    )?;

    for (name, p) in obj.object_properties() {
        writeln!(h, "{}* const m_{};", p.type_name(), name)?;
    }

    writeln!(
        h,
        "Private * m_d;
        bool m_ownsPrivate;"
    )?;

    for (name, p) in &obj.properties {
        writeln!(
            h,
            "Q_PROPERTY({0} {1} READ {1} {2}NOTIFY {1}Changed FINAL)",
            get_return_type(&p),
            name,
            write_property(name, p)
        )?;
    }

    writeln!(
        h,
        "
    explicit {constructor_name}(bool owned, QObject *parent);
public:
    explicit {constructor_name}(QObject *parent = nullptr);
    ~{constructor_name}() override;",
        constructor_name = obj.name
    )?;

    for (name, p) in &obj.properties {
        if p.is_object() {
            writeln!(h, "const {}* {}() const;", p.type_name(), name)?;
            writeln!(h, "{}* {}();", p.type_name(), name)?;
        } else {
            let (t, t2) = if p.optional && !p.is_complex() {
                ("QVariant", "const QVariant&")
            } else {
                (p.type_name(), p.property_type.cpp_set_type())
            };

            writeln!(h, "{} {}() const;", t, name)?;

            if p.write {
                writeln!(h, "void set{}({} v);", upper_initial(name), t2)?;
            }
        }
    }

    for (name, f) in &obj.functions {
        write!(h, "    Q_INVOKABLE {} {}(", f.return_type.name(), name)?;

        for (i, a) in f.arguments.iter().enumerate() {
            if i != 0 {
                write!(h, ", ")?;
            }

            write!(h, "{} {}", a.argument_type.cpp_set_type(), a.name)?;
        }

        writeln!(h, "){};", if f.mutable { "" } else { " const" })?;
    }

    if base_type(obj) == "QAbstractItemModel" {
        write_header_item_model(h, obj)?;
    }

    writeln!(h, "Q_SIGNALS:")?;

    for name in obj.properties.keys() {
        writeln!(h, "    void {}Changed();", name)?;
    }

    writeln!(h, "}};")?;

    Ok(())
}

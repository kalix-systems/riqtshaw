//! `cpp` is the module that generates the cpp code for the bindings

use crate::configuration::*;
use crate::configuration_private::*;
use crate::util::{snake_case, write_if_different};
use std::io::{Result, Write};

mod helpers;
use helpers::*;

pub fn write_header(conf: &Config) -> Result<()> {
    let mut h_file = conf.out_dir.join(&conf.cpp_file);

    h_file.set_extension("h");

    let mut header_buf = Vec::new();

    let guard = h_file
        .file_name()
        .unwrap()
        .to_string_lossy()
        .replace(".", "_")
        .to_uppercase();

    writeln!(
        header_buf,
        "/* generated by riqtshaw */
#ifndef {guard}
#define {guard}

#include <QtCore/QObject>
#include <QtCore/QAbstractItemModel>
",
        guard = guard
    )?;

    for name in conf.objects.keys() {
        writeln!(header_buf, "class {name};", name = name)?;
        writeln!(header_buf, "typedef {name}* {name}Ref;", name = name)?;
        writeln!(header_buf, "Q_DECLARE_METATYPE({name}Ref); \n", name = name)?;
    }

    for object in conf.objects.values() {
        write_header_object(&mut header_buf, object, conf)?;
    }

    writeln!(header_buf, "#endif // {guard}", guard = guard)?;

    write_if_different(h_file, &header_buf)?;

    Ok(())
}

fn write_header_item_model(header_buf: &mut Vec<u8>, obj: &Object) -> Result<()> {
    writeln!(header_buf, include_str!("cpp/header_item_model.hpp"))?;

    if model_is_writable(obj) {
        writeln!(
            header_buf,
            "    bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole) override;"
        )?;
    }

    for (name, item_prop) in &obj.item_properties {
        let read = property_type(item_prop);

        let read_write = if read == "QVariant" || item_prop.item_property_type.is_complex() {
            format!("const {}&", read)
        } else {
            read.clone()
        };

        if obj.object_type == ObjectType::List {
            writeln!(
                header_buf,
                "    Q_INVOKABLE {} {}(int row) const;",
                read, name
            )?;
            if item_prop.write {
                writeln!(
                    header_buf,
                    "    Q_INVOKABLE bool set{}(int row, {} value);",
                    upper_initial(name),
                    read_write
                )?;
            }
        } else {
            writeln!(
                header_buf,
                "    Q_INVOKABLE {} {}(const QModelIndex& index) const;",
                read, name
            )?;
            if item_prop.write {
                writeln!(
                    header_buf,
                    "    Q_INVOKABLE bool set{}(const QModelIndex& index, {} value);",
                    upper_initial(name),
                    read_write
                )?;
            }
        }
    }

    writeln!(
        header_buf,
        "
Q_SIGNALS:
    // new data is ready to be made available to the model with fetchMore()
    void newDataReady(const QModelIndex &parent) const;
private:
    QHash<QPair<int,Qt::ItemDataRole>, QVariant> m_headerData;
    void initHeaderData();
    void updatePersistentIndexes();"
    )?;

    Ok(())
}

fn write_header_object(header_buf: &mut Vec<u8>, obj: &Object, conf: &Config) -> Result<()> {
    writeln!(
        header_buf,
        "class {} : public {} {{ Q_OBJECT",
        obj.name,
        base_type(obj)
    )?;

    for object in conf
        .objects
        .values()
        .filter(|obj| obj.contains_object() && obj.name != obj.name)
    {
        writeln!(header_buf, "    friend class {};", object.name)?;
    }

    writeln!(
        header_buf,
        "public:
    class Private;
private:"
    )?;

    for (name, p) in obj.object_properties() {
        writeln!(header_buf, "{}* const m_{};", p.type_name(), name)?;
    }

    writeln!(
        header_buf,
        "Private * m_d;
        bool m_ownsPrivate;"
    )?;

    for (name, p) in &obj.properties {
        writeln!(
            header_buf,
            "Q_PROPERTY({0} {1} READ {1} {2}NOTIFY {1}Changed FINAL)",
            get_return_type(&p),
            name,
            write_property(name, p)
        )?;
    }

    writeln!(
        header_buf,
        "
    explicit {constructor_name}(bool owned, QObject *parent);
public:
    explicit {constructor_name}(QObject *parent = nullptr);
    ~{constructor_name}() override;",
        constructor_name = obj.name
    )?;

    for (name, prop) in &obj.properties {
        if prop.is_object() {
            writeln!(header_buf, "const {}* {}() const;", prop.type_name(), name)?;
            writeln!(header_buf, "{}* {}();", prop.type_name(), name)?;
        } else {
            let (t, t2) = if prop.optional && !prop.is_complex() {
                ("QVariant", "const QVariant&")
            } else {
                (prop.type_name(), prop.property_type.cpp_set_type())
            };

            writeln!(header_buf, "{} {}() const;", t, name)?;

            if prop.write {
                writeln!(header_buf, "void set{}({} v);", upper_initial(name), t2)?;
            }
        }
    }

    for (name, func) in &obj.functions {
        write!(
            header_buf,
            "Q_INVOKABLE {} {}(",
            func.return_type.name(),
            name
        )?;

        for (i, arg) in func.arguments.iter().enumerate() {
            if i != 0 {
                write!(header_buf, ", ")?;
            }

            write!(
                header_buf,
                "{} {}",
                arg.argument_type.cpp_set_type(),
                arg.name
            )?;
        }

        writeln!(header_buf, "){};", if func.mutable { "" } else { " const" })?;
    }

    if base_type(obj) == "QAbstractItemModel" {
        write_header_item_model(header_buf, obj)?;
    }

    writeln!(header_buf, "Q_SIGNALS:")?;

    for name in obj.properties.keys() {
        writeln!(header_buf, "    void {}Changed();", name)?;
    }

    writeln!(header_buf, "}};")?;

    Ok(())
}

fn write_cpp_object_properties(w: &mut Vec<u8>, o: &Object, lcname: &str) -> Result<()> {
    for (name, p) in &o.properties {
        let base = format!("{}_{}", lcname, snake_case(name));

        if p.is_object() {
            writeln!(
                w,
                "const {}* {}::{}() const
{{
    return m_{2};
}}
{0}* {1}::{2}()
{{
    return m_{2};
}}",
                p.type_name(),
                o.name,
                name
            )?;
        } else if p.is_complex() {
            writeln!(
                w,
                "{} {}::{}() const
{{
    {0} v;
    {3}_get(m_d, &v, set_{4});
    return v;
}}",
                p.type_name(),
                o.name,
                name,
                base,
                p.type_name().to_lowercase()
            )?;
        } else if p.optional {
            writeln!(
                w,
                "QVariant {}::{}() const
{{
    QVariant v;
    auto r = {2}_get(m_d);
    if (r.some) {{
        v.setValue(r.value);
    }}
    return r;
}}",
                o.name, name, base
            )?;
        } else {
            writeln!(
                w,
                "{} {}::{}() const
{{
    return {}_get(m_d);
}}",
                p.type_name(),
                o.name,
                name,
                base
            )?;
        }

        if p.write {
            let t = if p.optional && !p.is_complex() {
                "const QVariant&"
            } else {
                p.property_type.cpp_set_type()
            };

            writeln!(w, "void {}::set{}({} v) {{", o.name, upper_initial(name), t)?;

            if p.optional {
                if p.is_complex() {
                    writeln!(w, "    if (v.isNull()) {{")?;
                } else {
                    writeln!(
                        w,
                        "    if (v.isNull() || !v.canConvert<{}>()) {{",
                        p.type_name()
                    )?;
                }

                writeln!(w, "        {}_set_none(m_d);", base)?;

                writeln!(w, "    }} else {{")?;

                if p.type_name() == "QString" {
                    writeln!(
                        w,
                        "    {}_set(m_d, reinterpret_cast<const ushort*>(v.data()), v.size());",
                        base
                    )?;
                } else if p.type_name() == "QByteArray" {
                    writeln!(w, "    {}_set(m_d, v.data(), v.size());", base)?;
                } else if p.optional {
                    writeln!(
                        w,
                        "        {}_set(m_d, v.value<{}>());",
                        base,
                        p.type_name()
                    )?;
                } else {
                    writeln!(w, "        {}_set(m_d, v);", base)?;
                }
                writeln!(w, "    }}")?;
            } else if p.type_name() == "QString" {
                writeln!(
                    w,
                    "    {}_set(m_d, reinterpret_cast<const ushort*>(v.data()), v.size());",
                    base
                )?;
            } else if p.type_name() == "QByteArray" {
                writeln!(w, "    {}_set(m_d, v.data(), v.size());", base)?;
            } else {
                writeln!(w, "    {}_set(m_d, v);", base)?;
            }

            writeln!(w, "}}")?;
        }
    }
    Ok(())
}

fn write_cpp_object(w: &mut Vec<u8>, o: &Object, conf: &Config) -> Result<()> {
    let lcname = snake_case(&o.name);

    writeln!(
        w,
        "{}::{0}(bool /*owned*/, QObject *parent):
    {}(parent),",
        o.name,
        base_type(o)
    )?;

    initialize_members_zero(w, o)?;

    writeln!(
        w,
        "    m_d(nullptr),
    m_ownsPrivate(false)
{{"
    )?;

    if o.object_type != ObjectType::Object {
        writeln!(w, "    initHeaderData();")?;
    }

    writeln!(
        w,
        "}}

{}::{0}(QObject *parent):
    {}(parent),",
        o.name,
        base_type(o)
    )?;

    initialize_members_zero(w, o)?;

    write!(w, "    m_d({}_new(this", lcname)?;

    constructor_args(w, "", o, conf)?;

    writeln!(
        w,
        ")),
    m_ownsPrivate(true)
{{"
    )?;

    initialize_members(w, "", o, conf)?;

    connect(w, "this", o, conf)?;

    if o.object_type != ObjectType::Object {
        writeln!(w, "    initHeaderData();")?;
    }

    writeln!(
        w,
        "}}

{}::~{0}() {{
    if (m_ownsPrivate) {{
        {1}_free(m_d);
    }}
}}",
        o.name, lcname
    )?;

    if o.object_type != ObjectType::Object {
        writeln!(w, "void {}::initHeaderData() {{", o.name)?;

        for col in 0..o.column_count() {
            for (name, ip) in &o.item_properties {
                let empty = Vec::new();

                let roles = ip.roles.get(col).unwrap_or(&empty);

                if roles.contains(&"display".to_string()) {
                    writeln!(
                        w,
                        "    m_headerData.insert(qMakePair({}, Qt::DisplayRole), QVariant(\"{}\"));",
                        col,
                        name
                    )?;
                }
            }
        }

        writeln!(w, "}}")?;
    }

    write_cpp_object_properties(w, o, &lcname)?;

    for (name, f) in &o.functions {
        let base = format!("{}_{}", lcname, snake_case(name));

        write!(w, "{} {}::{}(", f.type_name(), o.name, name)?;

        for (i, a) in f.arguments.iter().enumerate() {
            write!(
                w,
                "{} {}{}",
                a.argument_type.cpp_set_type(),
                a.name,
                if i + 1 < f.arguments.len() { ", " } else { "" }
            )?;
        }

        writeln!(w, "){}\n{{", if f.mutable { "" } else { " const" })?;

        let mut arg_list = String::new();

        for a in &f.arguments {
            if a.type_name() == "QString" {
                arg_list.push_str(&format!(", {}.utf16(), {0}.size()", a.name));
            } else if a.type_name() == "QByteArray" {
                arg_list.push_str(&format!(", {}.data(), {0}.size()", a.name));
            } else {
                arg_list.push_str(&format!(", {}", a.name));
            }
        }

        if f.return_type.name() == "QString" {
            writeln!(
                w,
                "    {} s;
    {}(m_d{}, &s, set_qstring);
    return s;",
                f.type_name(),
                base,
                arg_list
            )?;
        } else if f.return_type.name() == "QByteArray" {
            writeln!(
                w,
                "    {} s;
    {}(m_d{}, &s, set_qbytearray);
    return s;",
                f.type_name(),
                base,
                arg_list
            )?;
        } else {
            writeln!(w, "    return {}(m_d{});", base, arg_list)?;
        }

        writeln!(w, "}}")?;
    }

    Ok(())
}

fn write_model_getter_setter(
    w: &mut Vec<u8>,
    index: &str,
    name: &str,
    ip: &ItemProperty,
    o: &Object,
) -> Result<()> {
    let lcname = snake_case(&o.name);

    let mut idx = index;

    // getter
    let mut r = property_type(ip);

    if o.object_type == ObjectType::List {
        idx = ", row";
        writeln!(w, "{} {}::{}(int row) const\n{{", r, o.name, name)?;
    } else {
        writeln!(
            w,
            "{} {}::{}(const QModelIndex& index) const\n{{",
            r, o.name, name
        )?;
    }

    if ip.type_name() == "QString" {
        writeln!(w, "    QString s;")?;
        writeln!(
            w,
            "    {}_data_{}(m_d{}, &s, set_{});",
            lcname,
            snake_case(name),
            idx,
            ip.type_name().to_lowercase()
        )?;

        writeln!(w, "    return s;")?;
    } else if ip.type_name() == "QByteArray" {
        writeln!(w, "    QByteArray b;")?;
        writeln!(
            w,
            "    {}_data_{}(m_d{}, &b, set_{});",
            lcname,
            snake_case(name),
            idx,
            ip.type_name().to_lowercase()
        )?;

        writeln!(w, "    return b;")?;
    } else if ip.optional {
        writeln!(w, "    QVariant v;")?;
        writeln!(
            w,
            "    v = {}_data_{}(m_d{});",
            lcname,
            snake_case(name),
            idx
        )?;

        writeln!(w, "    return v;")?;
    } else {
        writeln!(
            w,
            "    return {}_data_{}(m_d{});",
            lcname,
            snake_case(name),
            idx
        )?;
    }

    writeln!(w, "}}\n")?;

    if !ip.write {
        return Ok(());
    }

    //setter
    if r == "QVariant" || ip.is_complex() {
        r = format!("const {}&", r);
    }

    if o.object_type == ObjectType::List {
        idx = ", row";
        writeln!(
            w,
            "bool {}::set{}(int row, {} value)\n{{",
            o.name,
            upper_initial(name),
            r
        )?;
    } else {
        writeln!(
            w,
            "bool {}::set{}(const QModelIndex& index, {} value)\n{{",
            o.name,
            upper_initial(name),
            r
        )?;
    }

    writeln!(w, "    bool set = false;")?;

    if ip.optional {
        let mut test = "value.isNull()".to_string();
        if !ip.is_complex() {
            test += " || !value.isValid()";
        }

        writeln!(w, "    if ({}) {{", test)?;

        writeln!(
            w,
            "        set = {}_set_data_{}_none(m_d{});",
            lcname,
            snake_case(name),
            idx
        )?;

        writeln!(w, "    }} else {{")?;
    }

    if ip.optional && !ip.is_complex() {
        writeln!(
            w,
            "    if (!value.canConvert(qMetaTypeId<{}>())) {{
        return false;
    }}",
            ip.type_name()
        )?;
        writeln!(
            w,
            "    set = {}_set_data_{}(m_d{}, value.value<{}>());",
            lcname,
            snake_case(name),
            idx,
            ip.type_name()
        )?;
    } else {
        let mut val = "value";
        if ip.is_complex() {
            if ip.type_name() == "QString" {
                val = "value.utf16(), value.length()";
            } else {
                val = "value.data(), value.length()";
            }
        }

        writeln!(
            w,
            "    set = {}_set_data_{}(m_d{}, {});",
            lcname,
            snake_case(name),
            idx,
            val
        )?;
    }

    if ip.optional {
        writeln!(w, "    }}")?;
    }

    if o.object_type == ObjectType::List {
        writeln!(
            w,
            "    if (set) {{
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }}
    return set;
}}
"
        )?;
    } else {
        writeln!(
            w,
            "    if (set) {{
        Q_EMIT dataChanged(index, index);
    }}
    return set;
}}
"
        )?;
    }

    Ok(())
}

fn write_cpp_model(w: &mut Vec<u8>, o: &Object) -> Result<()> {
    let lcname = snake_case(&o.name);

    let (index_decl, index) = if o.object_type == ObjectType::Tree {
        (", quintptr", ", index.internalId()")
    } else {
        (", int", ", index.row()")
    };

    writeln!(w, "extern \"C\" {{")?;

    for (name, ip) in &o.item_properties {
        if ip.is_complex() {
            writeln!(
                w,
                "    void {}_data_{}(const {}::Private*{}, {});",
                lcname,
                snake_case(name),
                o.name,
                index_decl,
                ip.c_get_type()
            )?;
        } else {
            writeln!(
                w,
                "    {} {}_data_{}(const {}::Private*{});",
                ip.cpp_set_type(),
                lcname,
                snake_case(name),
                o.name,
                index_decl
            )?;
        }

        if ip.write {
            let a = format!("    bool {}_set_data_{}", lcname, snake_case(name));
            let b = format!("({}::Private*{}", o.name, index_decl);
            if ip.type_name() == "QString" {
                writeln!(w, "{}{}, const ushort* s, int len);", a, b)?;
            } else if ip.type_name() == "QByteArray" {
                writeln!(w, "{}{}, const char* s, int len);", a, b)?;
            } else {
                writeln!(w, "{}{}, {});", a, b, ip.c_set_type())?;
            }
            if ip.optional {
                writeln!(w, "{}_none{});", a, b)?;
            }
        }
    }

    writeln!(
        w,
        "    void {}_sort({}::Private*, unsigned char column, Qt::SortOrder order = Qt::AscendingOrder);",
        lcname,
        o.name
    )?;

    if o.object_type == ObjectType::List {
        writeln!(
            w,
            "
    int {lowercase_name}_row_count(const {name}::Private*);
    bool {lowercase_name}_insert_rows({name}::Private*, int, int);
    bool {lowercase_name}_remove_rows({name}::Private*, int, int);
    bool {lowercase_name}_can_fetch_more(const {name}::Private*);
    void {lowercase_name}_fetch_more({name}::Private*);
}}
int {name}::columnCount(const QModelIndex &parent) const
{{
    return (parent.isValid()) ? 0 : {column_count};
}}

bool {name}::hasChildren(const QModelIndex &parent) const
{{
    return rowCount(parent) > 0;
}}

int {name}::rowCount(const QModelIndex &parent) const
{{
    return (parent.isValid()) ? 0 : {lowercase_name}_row_count(m_d);
}}

bool {name}::insertRows(int row, int count, const QModelIndex &)
{{
    return {lowercase_name}_insert_rows(m_d, row, count);
}}

bool {name}::removeRows(int row, int count, const QModelIndex &)
{{
    return {lowercase_name}_remove_rows(m_d, row, count);
}}

QModelIndex {name}::index(int row, int column, const QModelIndex &parent) const
{{
    if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 && column < {column_count}) {{
        return createIndex(row, column, static_cast<quintptr>(row));
    }}
    return QModelIndex();
}}

QModelIndex {name}::parent(const QModelIndex &) const
{{
    return QModelIndex();
}}

bool {name}::canFetchMore(const QModelIndex &parent) const
{{
    return (parent.isValid()) ? 0 : {lowercase_name}_can_fetch_more(m_d);
}}

void {name}::fetchMore(const QModelIndex &parent)
{{
    if (!parent.isValid()) {{
        {lowercase_name}_fetch_more(m_d);
    }}
}}
void {name}::updatePersistentIndexes() {{}}",
            name = o.name,
            lowercase_name = lcname,
            column_count = o.column_count()
        )?;
    } else {
        writeln!(
            w,
            "
    int {1}_row_count(const {0}::Private*, option_quintptr);
    bool {1}_can_fetch_more(const {0}::Private*, option_quintptr);
    void {1}_fetch_more({0}::Private*, option_quintptr);
    quintptr {1}_index(const {0}::Private*, option_quintptr, int);
    qmodelindex_t {1}_parent(const {0}::Private*, quintptr);
    int {1}_row(const {0}::Private*, quintptr);
    option_quintptr {1}_check_row(const {0}::Private*, quintptr, int);
}}
int {0}::columnCount(const QModelIndex &) const
{{
    return {2};
}}

bool {0}::hasChildren(const QModelIndex &parent) const
{{
    return rowCount(parent) > 0;
}}

int {0}::rowCount(const QModelIndex &parent) const
{{
    if (parent.isValid() && parent.column() != 0) {{
        return 0;
    }}
    const option_quintptr rust_parent = {{
        parent.internalId(),
        parent.isValid()
    }};
    return {1}_row_count(m_d, rust_parent);
}}

bool {0}::insertRows(int, int, const QModelIndex &)
{{
    return false; // not supported yet
}}

bool {0}::removeRows(int, int, const QModelIndex &)
{{
    return false; // not supported yet
}}

QModelIndex {0}::index(int row, int column, const QModelIndex &parent) const
{{
    if (row < 0 || column < 0 || column >= {2}) {{
        return QModelIndex();
    }}
    if (parent.isValid() && parent.column() != 0) {{
        return QModelIndex();
    }}
    if (row >= rowCount(parent)) {{
        return QModelIndex();
    }}
    const option_quintptr rust_parent = {{
        parent.internalId(),
        parent.isValid()
    }};
    const quintptr id = {1}_index(m_d, rust_parent, row);
    return createIndex(row, column, id);
}}

QModelIndex {0}::parent(const QModelIndex &index) const
{{
    if (!index.isValid()) {{
        return QModelIndex();
    }}
    const qmodelindex_t parent = {1}_parent(m_d, index.internalId());
    return parent.row >= 0 ?createIndex(parent.row, 0, parent.id) :QModelIndex();
}}

bool {0}::canFetchMore(const QModelIndex &parent) const
{{
    if (parent.isValid() && parent.column() != 0) {{
        return false;
    }}
    const option_quintptr rust_parent = {{
        parent.internalId(),
        parent.isValid()
    }};
    return {1}_can_fetch_more(m_d, rust_parent);
}}

void {0}::fetchMore(const QModelIndex &parent)
{{
    const option_quintptr rust_parent = {{
        parent.internalId(),
        parent.isValid()
    }};
    {1}_fetch_more(m_d, rust_parent);
}}
void {0}::updatePersistentIndexes() {{
    const auto from = persistentIndexList();
    auto to = from;
    auto len = to.size();
    for (int i = 0; i < len; ++i) {{
        auto index = to.at(i);
        auto row = {1}_check_row(m_d, index.internalId(), index.row());
        if (row.some) {{
            to[i] = createIndex(row.value, index.column(), index.internalId());
        }} else {{
            to[i] = QModelIndex();
        }}
    }}
    changePersistentIndexList(from, to);
}}",
            o.name,
            lcname,
            o.column_count()
        )?;
    }
    writeln!(
        w,
        "
void {0}::sort(int column, Qt::SortOrder order)
{{
    {1}_sort(m_d, column, order);
}}
Qt::ItemFlags {0}::flags(const QModelIndex &i) const
{{
    auto flags = QAbstractItemModel::flags(i);",
        o.name, lcname
    )?;

    for col in 0..o.column_count() {
        if is_column_write(o, col) {
            writeln!(w, "    if (i.column() == {}) {{", col)?;
            writeln!(w, "        flags |= Qt::ItemIsEditable;\n    }}")?;
        }
    }

    writeln!(w, "    return flags;\n}}\n")?;

    for ip in &o.item_properties {
        write_model_getter_setter(w, index, ip.0, ip.1, o)?;
    }

    writeln!(
        w,
        "QVariant {}::data(const QModelIndex &index, int role) const
{{
    Q_ASSERT(rowCount(index.parent()) > index.row());
    switch (index.column()) {{",
        o.name
    )?;

    for col in 0..o.column_count() {
        writeln!(w, "    case {}:", col)?;

        writeln!(w, "        switch (role) {{")?;

        for (i, (name, ip)) in o.item_properties.iter().enumerate() {
            let empty = Vec::new();
            let roles = ip.roles.get(col).unwrap_or(&empty);
            if col > 0 && roles.is_empty() {
                continue;
            }

            for role in roles {
                writeln!(w, "        case Qt::{}:", role_name(role))?;
            }

            writeln!(w, "        case Qt::UserRole + {}:", i)?;

            let ii = if o.object_type == ObjectType::List {
                ".row()"
            } else {
                ""
            };

            if ip.optional && !ip.is_complex() {
                writeln!(w, "            return {}(index{});", name, ii)?;
            } else if ip.optional {
                writeln!(
                    w,
                    "            return cleanNullQVariant(QVariant::fromValue({}(index{})));",
                    name, ii
                )?;
            } else {
                writeln!(
                    w,
                    "            return QVariant::fromValue({}(index{}));",
                    name, ii
                )?;
            }
        }

        writeln!(w, "        }}\n        break;")?;
    }

    writeln!(
        w,
        "    }}
    return QVariant();
}}

int {}::role(const char* name) const {{
    auto names = roleNames();
    auto i = names.constBegin();
    while (i != names.constEnd()) {{
        if (i.value() == name) {{
            return i.key();
        }}
        ++i;
    }}
    return -1;
}}
QHash<int, QByteArray> {0}::roleNames() const {{
    QHash<int, QByteArray> names = QAbstractItemModel::roleNames();",
        o.name
    )?;
    for (i, (name, _)) in o.item_properties.iter().enumerate() {
        writeln!(w, "    names.insert(Qt::UserRole + {}, \"{}\");", i, name)?;
    }
    writeln!(
        w,
        "    return names;
}}
QVariant {0}::headerData(int section, Qt::Orientation orientation, int role) const
{{
    if (orientation != Qt::Horizontal) {{
        return QVariant();
    }}
    return m_headerData.value(qMakePair(section, static_cast<Qt::ItemDataRole>(role)), role == Qt::DisplayRole ?QString::number(section + 1) :QVariant());
}}

bool {0}::setHeaderData(int section, Qt::Orientation orientation, const QVariant &value, int role)
{{
    if (orientation != Qt::Horizontal) {{
        return false;
    }}
    m_headerData.insert(qMakePair(section, static_cast<Qt::ItemDataRole>(role)), value);
    return true;
}}
",
        o.name
    )?;

    if model_is_writable(o) {
        writeln!(
            w,
            "bool {}::setData(const QModelIndex &index, const QVariant &value, int role)\n{{",
            o.name
        )?;

        for col in 0..o.column_count() {
            if !is_column_write(o, col) {
                continue;
            }

            writeln!(w, "    if (index.column() == {}) {{", col)?;

            for (i, (name, ip)) in o.item_properties.iter().enumerate() {
                if !ip.write {
                    continue;
                }

                let empty = Vec::new();

                let roles = ip.roles.get(col).unwrap_or(&empty);

                if col > 0 && roles.is_empty() {
                    continue;
                }

                write!(w, "        if (")?;

                for role in roles {
                    write!(w, "role == Qt::{} || ", role_name(role))?;
                }

                writeln!(w, "role == Qt::UserRole + {}) {{", i)?;

                let ii = if o.object_type == ObjectType::List {
                    ".row()"
                } else {
                    ""
                };

                if ip.optional && !ip.is_complex() {
                    writeln!(
                        w,
                        "            return set{}(index{}, value);",
                        upper_initial(name),
                        ii
                    )?;
                } else {
                    let pre = if ip.optional {
                        "!value.isValid() || value.isNull() ||"
                    } else {
                        ""
                    };

                    writeln!(
                        w,
                        "            if ({}value.canConvert(qMetaTypeId<{}>())) {{",
                        pre,
                        ip.type_name()
                    )?;

                    writeln!(
                        w,
                        "                return set{}(index{}, value.value<{}>());",
                        upper_initial(name),
                        ii,
                        ip.type_name()
                    )?;

                    writeln!(w, "            }}")?;
                }

                writeln!(w, "        }}")?;
            }

            writeln!(w, "    }}")?;
        }

        writeln!(w, "    return false;\n}}\n")?;
    }

    Ok(())
}

fn constructor_args(w: &mut Vec<u8>, prefix: &str, o: &Object, conf: &Config) -> Result<()> {
    let lcname = snake_case(&o.name);

    for (name, prop) in &o.properties {
        if let Type::Object(object) = &prop.property_type {
            write!(w, ", {}m_{}", prefix, name)?;
            constructor_args(w, &format!("m_{}->", name), object, conf)?;
        } else {
            write!(w, ",\n        {}", changed_f(o, name))?;
        }
    }
    if o.object_type == ObjectType::List {
        writeln!(
            w,
            include_str!("cpp/list_constructor_lambdas.cpp_string"),
            name = o.name,
            col_count = o.column_count() - 1
        )?;
    }

    if o.object_type == ObjectType::Tree {
        writeln!(
            w,
            include_str!("cpp/tree_constructor_lambdas.cpp_string"),
            name = o.name,
            snake_case_class_name = lcname,
            col_count = o.column_count() - 1
        )?;
    }

    // add_factory_lambdas(w, o)?;

    Ok(())
}

fn add_factory_lambdas(write_buf: &mut Vec<u8>, object: &Object) -> Result<()> {
    let qobject_type_properties = object.item_properties.iter().filter(|(_, prop)| {
        if let Type::Object(_) = prop.item_property_type {
            true
        } else {
            false
        }
    });

    for (_, prop) in qobject_type_properties {
        let nested_model_name = if let Type::Object(obj) = &prop.item_property_type {
            obj.name.clone()
        } else {
            break;
        };

        writeln!(
            write_buf,
            ",
            []() {{
                {nested_model_name} alloc = new Messages;
                 return alloc;
                }}",
            nested_model_name = nested_model_name,
        )?;
    }

    Ok(())
}

// main entry point for producing the
// generated cpp code
pub fn write_cpp(conf: &Config) -> Result<()> {
    let mut write_buf = Vec::new();

    let mut h_file = conf.out_dir.join(&conf.cpp_file);
    h_file.set_extension("h");
    let file_name = h_file.file_name().unwrap().to_string_lossy();

    // print header
    writeln!(
        write_buf,
        "/* generated by riqtshaw */\n#include \"{}\"",
        file_name
    )?;

    // start name space
    writeln!(write_buf, "namespace {{")?;

    for option in conf.optional_types() {
        if option != "QString" && option != "QByteArray" {
            writeln!(
                write_buf,
                "
    struct option_{} {{
    public:
        {0} value;
        bool some;
        operator QVariant() const {{
            if (some) {{
                return QVariant::fromValue(value);
            }}
            return QVariant();
        }}
    }};
    static_assert(std::is_pod<option_{0}>::value, \"option_{0} must be a POD type.\");",
                option
            )?;
        }
    }

    writeln!(write_buf, include_str!("cpp/complex_types.cpp_string"))?;

    for (name, object) in conf.objects.iter() {
        for prop_name in object.non_object_property_names() {
            writeln!(
                write_buf,
                "inline void {fn_name}({class_name}* o)",
                fn_name = changed_f(object, prop_name),
                class_name = name
            )?;
            writeln!(write_buf, "{{\nQ_EMIT o->{}Changed();\n}}", prop_name)?;
        }
    }

    // end namespace
    writeln!(write_buf, "}}")?;

    for o in conf.objects.values() {
        if o.object_type != ObjectType::Object {
            write_cpp_model(&mut write_buf, o)?;
        }

        writeln!(write_buf, "extern \"C\" {{")?;

        write_object_c_decl(&mut write_buf, o, conf)?;

        writeln!(write_buf, "}};\n")?;
    }

    for o in conf.objects.values() {
        write_cpp_object(&mut write_buf, o, conf)?;
    }

    let file = conf.out_dir.join(&conf.cpp_file);

    write_if_different(file, &write_buf)
}
